* CS10 강의 내용 정리

## CS07 | 프로세스 스케줄링

### 운영체제 역사

> 역사적으로 어떤 순서대로 만들어졌는지, 예전 시스템들은 어떻게 생겼고 요즘 시스템은 어떻게 생겼고 그 사이에 어떤 변화가 있었는지를 시간의 흐름에 따라서 보는 것이 무언가를 이해하는데 많은 도움이 됩니다.
>
> 옛날 시스템이 왜 그랬었꼬, 거기에 뭐가 필요해서 다음엔 어떤 시스템이 만들어졌고, 이런 차이점들을 학습하다보면 현대적인 시스템들이 왜 그런 형태를 가지고 있는지를 조금 더 알기 쉽게 접근할 수 있습니다.
>
> 그리고 시스템에서 사용되는 용어들도 한 번 그 이름이 붙어지면 관용적으로 계속 그 용어를 쓰는 경우가 많으니, 용어에 대해 궁금하다면 그 용어가 붙은 이유를 알고 있으면 이해하기에 편할 것입니다.

1. 초기 단일 시스템

	<img src="https://user-images.githubusercontent.com/92504186/150926439-1e6dc4d0-58d3-4ee6-a485-5ef58fb42980.jpg" alt="SS 2022-01-25 PM 03 54 47" style="zoom:50%;" />

	* 요즘은 컴퓨터라하면 특정 목적이 있는게 아니라 어떤 프로그램을 실행하느냐에 따라 다른 목적이 되는 포괄적인 목적에서의 컴퓨터, General Purpose Computer를 의미한다.

		하지만 초기의 컴퓨터라 불렸던 시스템들은 단일 목적이었다. (전원을 입력하면 코드를 입력하는 프롬프트만 뜸..)

		따라서 컴퓨터에 어떤 입력을 주기 위해서는 입력할 내용을 모두 컴파일러처럼 작업해서 정리해서 프로세서의 특정한 위치에다가 입력을 주고 버튼을 누르면 출력되는 식이었기 때문에, 그런 작업을 해주는 `Operator`가 필수적으로 필요했다.(Operator: 컴퓨터를 운영할줄 아는 사람)

		

2. 일괄 처리 시스템

	<img src="https://user-images.githubusercontent.com/92504186/150927595-8f46c414-d668-4c2e-bc1e-d80c843cb7d9.jpg" alt="SS 2022-01-25 PM 04 04 27" style="zoom:50%;" />

	* 에러가 발생하면 다시 코드를 카드로 작성해 Operater에게 가져다 주고 하는 작업을 개선하고자, `Operating System(OS)`를 만들게 됐다.

		메모리에다가 프로그램을 다 올리고, 올린 내용들을 차례차례 실행하도록 하는 컴퓨터를 생각했고, 그 올리는걸 관리해주는 프로그램이 OS의 시작이었다. (거주관리(resident management): 한꺼번에 내용을 다 올리고, 그 내용을 차례차례 실행하면서, 올린걸 관리해주는 방법)

	* 이제 OS가 관리해주기 때문에 프로그램을 빨리빨리 교체가 가능해졌다. 하지만 프로그램을 올리고 실행까지해서 일괄적으로 처리를 해야하기 때문에, `배치 프로세싱`을 사용하게 됐다.(요즘엔 배치라는 용어의 의미가 프로그램이 끝날 때까지 입력과 출력을 다 멈춰놓고, 프로그램이 끝나면 입력과 출력을 한꺼번에 처리하는 걸 의미함)



3. 다중 프로그래밍 시스템 (CPU 스케줄링)

	<img src="https://user-images.githubusercontent.com/92504186/150930246-4d334a1b-8670-4e0b-a934-4f8c64a6d518.jpeg" alt="IMG_90B7E1F1278D-1" style="zoom:50%;" />

	* 프로그램이 돌아가는 동안 입력, 출력을 한꺼번에 다 기록해놨다가, 프로그램 동작이 끝나면 일괄적으로 처리하는 방법이 생겨나니까, 이제 점점 여러 프로그래밍이 돌아가는게 필요한 시대가 됐다.

	* 프로그램을 컴퓨터에 올리는 방법은 TypeWriter를 사용했다.

	* 이제 프로그램이 바로 출력을 하는게 아니라 I/O로 사용되는 Tape에 출력을 저장하게 됐는데, I/O 저장장치는 컴퓨터에 비해 매우 느리게 동작했기 때문에, 컴퓨터의 프로그램A가 저장장치에 값을 쓰거나 읽어와야하는 순간에는 해당 컴퓨터의 프로그램A가 정지되고 읽어오거나 쓰는 작업이 끝나면 이제 프로그램A의 차례가 끝나고 B로 넘어가게 됐다.

		이렇게 되니, 프로그램이 멈춰있는 동안 컴퓨터의 CPU가 놀게 되는 경우가 생기기 때문에 `CPU 스케줄링`이 필요하게 됐다. I/O로 가야할 경우가 생기면 실행중인 프로그램 말고 다른 프로그램을 돌리고 하는 방법을 사용하게 되었고, 이 방법을 멀티 프로그래밍이라고 불렀다.



4. 시분할 시스템

	<img src="https://user-images.githubusercontent.com/92504186/150932420-22384754-5ab7-41eb-a56e-ffd5332881c9.jpg" alt="SS 2022-01-25 PM 04 38 25" style="zoom:50%;" />

	* 다중 프로그래밍 시스템에서는, 만약 프로그램A를 쓰려는 사람이 있으면, A가 돌아가다 멈추고, B,C가 돌아가고 B,C도 끝나야 A가 끝날 수 있는 기회를 얻게 되므로, 아직 여러 명이 동시에 쓰기에는 불편한 시스템이었다. 이를 개선하고자 시분할(Time Sharing) 시스템이 생겼다.

		시분할 시스템은 정해놓은 시간동안 규칙적으로 번갈아가면서 프로그램들이 돌아가게 된다. -> UNIX의 시초



5. 인터럽트 기반 시스템

	<img src="https://user-images.githubusercontent.com/92504186/150933821-4ba8529d-ce5c-45dc-beab-ba2da9a70f14.jpg" alt="SS 2022-01-25 PM 04 43 42" style="zoom:50%;" />

	* 하드웨어에 있는 키보드/마우스가 움직일 때마다 CPU한테 인터럽트를 넣어준다. 하드웨어를 통한 입력을 메인 메모리 어딘가에 저장하면서 인터럽트를 발생시켜준다. 
	* 부트로더는 바이오스라 해서, 어떤 운영체제가 깔려있는지를 확인해서 로딩해주는 작은 프로그램이다.



### Virtual Memory와 Data Bus

<img src="https://user-images.githubusercontent.com/92504186/150934758-a73278b5-a80c-4083-bd2e-75f994e0f8a7.jpg" alt="SS 2022-01-25 PM 04 54 08" style="zoom:50%;" />

> 왜 Bus라고 부를까? -> 정해진 (여러)경로를 일정 시간마다 왔다갔다 하기 때문
>
> 시스템 메모리 뿐 아니라, 비디오 카드도 연결하고, 하드 디스크도 연결함



### 컴퓨터 구조

![IMG_D2716C79F9BA-1](https://user-images.githubusercontent.com/92504186/150935219-80f75b6b-0367-49c3-ba48-095e4d152d21.jpeg)

* Queue? -> 대기열, 줄을 의미하는 단어

	cf) Buffer? -> 기차 사이 완충장치를 의미하는 단어

* CPU와 메인 메모리 간의 속도차가 크기 때문에, 누군가가 계속 스케줄링 해줘야 할 필요성이 있다. 

* Job Scheduler는 CPU 입장에서는 되게 느린 스케줄러이기 때문에 Long-term Scheduler라고 하고, CPU Scheduler는 굉장히 빠르게 프로세스들을 바꿔줘야 하기 때문에 Short-term Scheduler라고 한다.

* Job을 메모리에 로딩하면 Process가 만들어짐



### 프로세스

![150080335-e707150e-9ad4-4dc8-b259-79eef50b2e40](https://user-images.githubusercontent.com/92504186/150936318-403a9770-348d-49be-a3b8-ea9874ae2cc0.png)

