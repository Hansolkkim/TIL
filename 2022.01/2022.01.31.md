* 독서

# 객체지향의 사실과 오해

## 01. 협력하는 객체들의 공동체

* 상태와 프로퍼티

	**상태**는 특정 시점에 객체가 가지고 있는 정보의 집합으로 객체의 구조적 특징을 표현한다. 객체의 상태는 객체에 존재하는 정적인 프로퍼티와 동적인 프로퍼티 값으로 구성된다. 객체의 프로퍼티는 단순한 값과 다른 객체를 참조하는 링크로 구분할 수 있다.

	

* 행동

	1. 상태와 행동

		객체는 스스로의 행동에 의해서만 상태가 변경되는 것을 보장함으로써 객체의 자율성을 유지한다.

		객체의 행동은 객체의 상태를 변경시키지만 행동의 결과는 객체의 상태에 의존적이다.

	2. 협력과 행동

		객체의 행동은 객체가 협력에 참여할 수 있는 유일한 방법이다. 객체는 수신된 메시지에 따라 적절히 행동하면서 협력에 참여하고 그 결과로 자신의 상태를 변경한다.

	> **행동**이란 외부의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동이다. 행동의 결과로 객체는 자신의 상태를 변경하거나 다른 객체에게 메시지를 전달할 수 있다. 객체는 행동을 통해 다른 객체와의 협력에 참여하므로 외부에 가시적이어야 한다.

	

* 식별자

	> **식별자**는 어떤 객체를 다른 객체와 구분하는 데 사용하는 객체의 프로퍼티다. ~~값은 식별자를 가지지 않기 때문에~~ 상태를 이용한 동등성 검사를 통해 두 인스턴스를 비교해야 한다. 객는 상태가 변경될 수 있기 때문에 식별자를 이용한 동일성 검사를 통해 두 인스턴스를 비교할 수 있다.

	

* 행동이 상태를 결정한다.

	OOP 초보자들은 객체에게 필요한 상태가 무엇인지를 찾고, 프로퍼티를 추가한다. 그러고 나서야 행동을 어떻게 구성할지 고민하고 추가한다. 하지만 이렇게 상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 설계에 나쁜 영향을 준다.

	1. 상태를 먼저 결정할 경우 캡슐화가 저해된다. 상태에 초점을 맞출 경우 상태가 객체 내부로 깔끔하게 캡슐화되지 못 하고 공용 인터페이스에 그대로 노출되버릴 확률이 높아진다.
	2. 객체를 협력자가 아닌 고립된 섬으로 만든다. 객체가 필요한 이유는 애플리케이션의 문맥 내에서 다른 객체와 협력하기 위해서다. 불행하게도 상태를 먼저 고려하는 방식은 협력이라는 문맥에서 멀리 벗어난 채 객체를 설계하게 함으로써 자연스럽게 협력에 적합하지 못한 객체를 창조하게 된다.
	3. 객체의 재사용성이 저해된다. 객체의 재사용성은 다양한 협력에 참여할 수 있는 능력에서 나온다. 상태에 초점을 맞춘 객체는 다양한 렵력에 참여하기 어렵기 때문에 재사용성이 저하될 수 밖에 없다.

	-> 협력에 참여하는 훌륭한 객체 시민을 양성하기 위한 가장 중요한 덕문은 상태가 아니라 **행동**에 초점을 맞추는 것이다.우리가 애플리케이션 안에서 어떤 행동을 원하느냐가 어떤 객체가 적합한지를 결정한다. 객체의 적합성을 결정하는 것은 상태가 아니라 객체의 행동이다.

	

* 의인화(anthropomorphism)

	소프트웨어의 객체는 현실 세계의 객체에 대한 모방이 아니다. 두 객체의 가장 큰 차이점은, 현실 속에서는 수동적인 객체가 소프트웨어 객체로 구현될 때는 능동적이 된다는 것이다.

	-

* 은유(metaphor)

	객체지향의 세계와 현실 세계 사이에는 전혀 상관이 없는 것은 아니다. 모방이나 추상화의 수준이 아닌, **은유**란 관점에서 유사성을 가지고 있다.

	현실 속의 객체의 의미 일부가 소프트웨어 객체로 전달되기 때문에 프로그램 내의 객체는 현실 속의 객체에 대한 은유다.

	은유는 표현적 차이(representational gap) 또는 의미적 차이(semantic gap)라는 논점과 관련성이 깊다. 여기서 차이란, 소프트웨어에 대해 사람들이 생각하는 모습과 실제 소프트웨어의 표현 사이의 차이를 의미한다. 은유 관계에 있는 실제 객체의 이름을 소프트웨어 객체의 이름으로 사용하면 표현적 차이를 줄여 소프트웨어의 구조를 쉽게 예측할 수 있게된다.