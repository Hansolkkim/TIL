# CS05 | 메모리 시뮬레이터

## 📌셀프 체크리스트

- [x] 함수 동작을 확인하기 위한 상위 프로그램 작성 여부
- [x] init() 동작 구현 여부
- [x] setSize() 타입별 크기 지정 구현 여부
- [x] malloc() 힙 메모리 할당 구현 여부
- [x] free() 힙 메모리 해제 구현 여부
- [x] call() 함수 호출 구현 여부
- [x] returnFrom() 함수 리턴 구현 여부
- [x] usage() 스택과 힙 사용 현황 리턴 구현 여부
- [x] callstack() 호출 스택 구현 여부
- [x] heapdump() 힙 사용 상태 구현 여부
- [x] garbageCollect() 사용하지 않는 힙 메모리 해제 구현 여부

## 📌스스로 확인할 사항

### 1. 구현한 각 함수 동작이 정상적으로 동작하는지 확인하기 위해서 어떤 방식으로 테스트했는지 정리한다.

시나리오에 해당하는 클래스를 선언해, 해당 기능에 기대하는 기능이 제대로 동작하는지 테스트하는 시나리오를 메소드 형태로 작성했습니다.

예를 들어 setSize() 기능을 테스트하는 시나리오의 경우, 먼저 일반적인 기능으로 원하는 이름을 가지고 정해진 크기를 가지는 타입을 등록해주는 기능과, 정해진 사이즈 외의 크기로 타입을 만드려는 경우와 이미 등록된 타입의 값을 변경하려고 하는 경우에도 해당 기능이 어떻게 작동하는지 확인하는 시나리오를 아래의 코드와 같이 작성했습니다.

```swift
func setSizeScenario(to memory: Memory) {
    /*
     Bool = 1, Short = 2, Float = 4, Int = 8, Long = 16 크기로 setType
     */
    memory.setSize(type: "Bool", length: 1)
    memory.setSize(type: "Short", length: 2)
    memory.setSize(type: "Float", length: 4)
    memory.setSize(type: "Int", length: 8)
    memory.setSize(type: "Long", length: 16)
    
    // 1,2,4,8,16,32 이외의 length의 Type을 등록하려는 경우
    memory.setSize(type: "Sol", length: 3)
    // 이미 등록된 Type의 값을 변경하려는 경우
    memory.setSize(type: "Bool", length: 4)
}
```



### 2. 일반적인 프로세스 메모리 모델에 대해 학습하고 정리한다.

* 메모리에는 각 프로세스마다, Text, Data, Heap, Stack 순으로 Low address에서 High address로 메모리에 할당됩니다.

	![스크린샷 2022-01-19 오후 3 56 01](https://user-images.githubusercontent.com/92504186/150079722-e0310ebd-920b-4684-939d-abcc29ba14c0.png)

	1. `Text`

		텍스트 영역은 흔히 코드 영역이라고 하는데, 프로그램을 실행시키기 위한 명령문들이 기계어 형태로 저장됩니다. 

	2. `Data`

		데이터 영역은 작성한 코드의 전역변수(Global varialble), 정적변수(Static variable) 등이 저장되는 공간입니다. 생성된 클래스에 포함된 함수(메소드)들 또한 이 영역에 저장됩니다.

	3. `Heap`

		프로그래머에 의해 관리되는 영역입니다. 동적으로 할당할 변수들이 여기에 저장됩니다. 클래스의 인스턴스를 생성하면 해당 인스턴스는 이 영역에 저장됩니다.

		동적 데이터의 영역입니다. 메모리 주소 값에 의해서만 참조되고 사용됩니다.

	4. `Stack`

		함수를 호출할 때 지역변수, 매개변수들, 그리고 함수의 반환 주소 등이 저장되는 공간입니다. 그리고 함수가 종료되면 해당 함수에 할당된 변수들을 스택 영역 메모리에서 해제시킵니다.

* 프로세스의 상태 전이 과정은 다음과 같습니다.

	![스크린샷 2022-01-19 오후 4 00 29](https://user-images.githubusercontent.com/92504186/150080335-e707150e-9ad4-4dc8-b259-79eef50b2e40.png)

	1. Dispatch (ready -> running)

		여러 프로세스들 중 한 프로세스를 선정해 CPU에 할당하는 과정입니다.

	2. Interrupt (running -> ready)

		할당된 CPU 시간이 지나면 Timeout Interrupt가 발생하여 CPU를 다른 프로세스에 양도하고 ready상태로 전이되는 과정입니다.

	3. Block (running -> waiting)

		I/O 등의 자원 요청 후 즉시 할당받을 수 없기 때문에, 할당받을 때까지 기다리기 위해 running에서 waiting상태로 전이되는 과정입니다.

		I/O 처리는 CPU가 아닌 I/O 프로세스가 담당하기 때문에 해당 전이 과정이 발생합니다.

	4. Wakeup (waitin -> ready)

		필요한 자원이 할당됐을 때 프로세스가 waiting에서 ready 상태로 전이되는 과정입니다.

### 리눅스 운영체제를 기준으로 가상 메모리 관리 방식에 대해 학습하고 정리한다.

1. **가상 메모리란?**

	가상 메모리는 메모리를 관리하는 방법 중 하나로, 각 프로그램에 실제 메모리 주소가 아닌 `가상의 메모리 주소`를 주는 방식을 말합니다. 가상 메모리를 이용하면, 실제 물리 메모리가 가지고 있는 크기를 논리적으로 확장하여 사용할 수 있습니다.

	가상 메모리를 사용했을 때의 장점으로는 아래 3가지가 있습니다.

	* *논리적으로 메모리를 확장하여 사용할 수 있다*.

		*실제 물리 메모리가 가지는 공간보다 더 큰 공간으로 확장할 수 있습니다. 실제 물리 메모리가 가지고 있는 공간 이상으로 데이터를 저장할 수는 없지만, RAM이나 디스크, 레지스터 등의 공간을 연속적으로 가상 공간에 매핑할 수 있습니다.*

	* *프로세스들에게 동일한 메모리 공간을 제공해 줄 수 있다.*

		*사용자는 물리 메모리 정보가 아닌, OS가 제공해주는 가상 메모리 공간만 신경쓰면 됩니다. 만약 가상 메모리 없이 물리 메모리만을 사용하는 경우에는 두 개의 프로세스가 동시에 돌아갈 때 두 개의 프로세스는 서로의 물리 메모리 공간을 실시간으로 파악하면서 동작해야하게 됩니다.*

		*하지만 가상 메모리를 사요한다면, 사용자는 단지 OS가 제공해주는 가상 메모리 영역만 이용하면 됩니다. 나머지 관리는 OS 내부에서 처리됩니다.*

	* *메모리 관리에 효율적이다.*

		*컴퓨터를 이용하면 많은 데이터를 생성, 삭제, 수정하는 동작을 무수히 수행합니다. 따라서 연속적으로 할당됐던 데이터들도 시간이 지나면 불연속적으로 할당되게 됩니다. 가상 메모리를 이용하면 이런 불연속적으로 할당된 메모리를 `논리적으로 연속적인 메모리 형태`로 사용 가능합니다.*

	가상 메모리는 메모리를 늘리는 일을 하는 것만 아닙니다. 메모리 관리 서브 시스템은 다음과 같은 것들을 제공해줍니다.

	* **넓은 주소 공간** - OS는 시스템이 실제 가진 것보다 훨씬 많은 양의 메모리를 가지고 있는 것처럼 보이게 합니다. 
	* **보호** - 시스템의 각 프로세스는 각자의 독립된 가상 주소 공간을 갖습니다. 이들 가상 주소 공간은 서로 완벽하게 분리돼있어서, 어떤 응용 프로그램을 실행하는 프로세스는 다른 것에 영향을 줄 수 없습니다. 또 하드웨어 가상 메모리 메커니즘은 메모리 영역에 쓰기를 금지할 수 있게 합니다.
	* **메모리 매핑** - 메모리 매핑은 이미지와 데이터 파일을 프로세스의 주소 공간에 매핑하기 위해 사용됩니다. 메모리 매핑에서 파일의 내용은 프로세스의 가상 주소공간에 직접 연결됩니다.
	* **공정한 물리적 메모리 할당** - 메모리 관리 서브 시스템은 시스템에서 실행중인 프로세스들이 서로 공정하게 물리적 메모리를 공유할 수 있게 합니다.
	* **공유 가상 메모리** - 가상 메모리는 프로세스들이 분리된 가상 주소공간을 가질 수 있도록 하지만, 때로는 프로세스들이 메모리를 공유하는 것이 필요할 때가 있습니다. 그 때 공유 메모리는 두개 이상의 프로세스가 모두에게 공통적인 메모리를 통해 정보를 교환함으로써, 프로세스간 통신 매커니즘으로 사용될 수 있습니다.

	

2. **요구 페이징 (Demand Paging)**

	실제로 가상 메모리보다 훨씬 적은 물리적 메모리만 있기 때문에, OS는 물리적 메모리가 비효율적으로 사용되지 않도록 주의해야 한다. 물리적 메모리를 절약하는 방법 하나는, 실행 중인 프로그램이 현재 사용하는 가상 페이지만을 로드하는 것입니다. 예를 들어, 데이터 베이스 프로그램이 데이터베이스에 질의를 한다고 가정하면, 이 경우 모든 데이터베이스가 메모리에 로드될 필요는 없습니다. 데이터베이스 질의가 검색 질의라면 데이터베이스 프로그램에서 새로운 레코드를 추가하는 것을 처리하는 부분의 코드를 읽어들일 필요는 없을 것입니다. 이렇게 가상 페이지들이 접근되는 경우에만 메모리에 읽어들이는 기법을 `요구 페이징`이라고 합니다.

3. **스와핑 (Swapping)**

	프로세스가 가상 페이지를 물리적 메모리에 가져와야 하는데, 비어있는 물리적 페이지가 없다면, OS는 물리적 메모리에서 다른 페이지를 제거하여, 가져올 페이지를 위한 공간을 마련해야 합니다.

	물리적 메모리에서 제거될 페이지가 이미지나 데이터 파일에서 온 것이고, 이 페이지에 쓰여진 것이 없다면 페이지의 내용을 저장할 필요는 없습니다. 대신 그냥 제거를 하고, 나중에 다시 필요하게 되면 이미지나 데이터 파일로부터 다시 메모리에 읽어들이면 됩니다.

	그러나 페이지가 변경되었다면, OS는 페이지의 내용을 나중에 다시 사용할 수 있도록 보존해야 합니다. 이런 페이지를 dirty page라고 하며, 이를 메모리에서 제거할 때 스왑 파일(swap file)이라는 특별한 파일에 저장합니다. 스왑 파일에 접근하는 것은 프로세서나 물리적 메모리의 속도에 비해 매우 오래 걸리므로, OS는 페이지를 디스크에 기록할 필요성과, 다시 사용될 수 있도록 메모리로 가져오게 될 필요성을 잘 다루어야 합니다.

	리눅스는 시스템에서 제거될 페이지를 공정하게 선택하기 위해, 가장 최근에 사용된(Least Recently Used, LRU) 페이지 수명(paging aging) 기법을 사용합니다. 이 기법에서 시스템의 모든 페이지는 그 페이지에 접근될 때마다 변경되는 수명을 갖고 있습니다. 페이지는 자주 접근될수록 젊어지고, 적게 접근될수록 나이가 들게 됩니다. 나이가 든 페이지는 스와핑의 좋은 후보가 됩니다.

4. **Linux 가상 메모리 관리 - Paging, Swap**

	리눅스는 부족한 메모리를 위해 페이징, 스왑을 통해 부족한 메모리를 보조 저장장치인 하드 디스크로 사용하게 된다.

	![스크린샷 2022-01-19 오후 4 30 43](https://user-images.githubusercontent.com/92504186/150084373-7b03d301-a085-4270-aa58-a6b7310a363f.png)

	이를 `가상 메모리`라고 합니다.

	리눅스의 경우 `free`명령을 통해 가상 메모리를 확인할 수 있습니다.

	```c
	> sudo free -m
	```

	

	<img width="718" alt="image" src="https://user-images.githubusercontent.com/92504186/150085219-a938368f-a407-4360-a305-894fa7be130a.png">

	해당 명령을 통해 메모리 사용량을 Megabyte 단위로 확인할 수 있습니다.

	total이 전체 사용가능한 swap 메모리이고, used가 현재 사용중인 메모리, free는 사용 가능한 메모리 용량입니다.

	리눅스는 가상 메모리를 파티션으로 관리하므로, `swapon`명령을 통해 현재 가상 메모리로 설정된 파티션을 확인할 수 있습니다.

	```c
	> sudo swapon -s
	```

	<img width="726" alt="스크린샷 2022-01-19 오후 4 39 37" src="https://user-images.githubusercontent.com/92504186/150085564-d6a5a1c2-e902-43e3-b5f5-d2575abe9cf4.png">

	리눅스는 스왑 또한 파티션 기반으로 관리합니다. `fdisk`명령으로 현재 구성된 리눅스의 파티션을 확인할 수 있습니다.

	```c
	> fdisk -l
	```

	<img width="585" alt="스크린샷 2022-01-19 오후 4 42 10" src="https://user-images.githubusercontent.com/92504186/150085926-d83458fe-1c40-4d2b-ae85-9750d6522615.png">

	지금 제 리눅스 시스템은 스왑 메모리를 사용하고 있지 않습니다. 리눅스는 기본적으로 물리 메모리를 먼저 사용하고 물리 메모리가 설정한 값보다 부족한 경우 가상 메모리를 사용하는 방식을 사용합니다.

	가상 메모리의 크기를 설정하는 방법은 swap으로 파일이나 파티션을 등록하여 설정할 수 있습니다. 새로 파일을 생성하여, `mk swap`명령을 통해 등록이 가능합니다. 

	```c
	> sudo fallocate l 10MB /var/swapfile
	```

	위 명령을 입력하면 /var 디렉토리에 swapfile이라는 10MB 파일을 생성하게 됩니다. 그리고 아래 명령으로 해당 파일의 접근 권한을 시스템 접근으로 변경합니다.

	```c
	> sudo chmod 600 /var/swapfile
	```

	<img width="628" alt="image" src="https://user-images.githubusercontent.com/92504186/150086917-a1011fcf-65a8-47a8-954f-f18a2baf5de2.png">

	이제 `mkswap`명령으로 swap으로 활용할 수 있습니다.

	```c
	> sudo mkswap /var/swapfile
	```

	<img width="571" alt="스크린샷 2022-01-19 오후 4 52 40" src="https://user-images.githubusercontent.com/92504186/150087401-77d92e98-1db3-4efe-90c9-9f8423f3f8cc.png">

	이렇게 생성한 swapfile을 영구적으로 사용하고자 한다면, `/etc/fstab`에 추가해주면 됩니다.

	생서한 스왑의 사용을 해제하고자 한다면 아래의 명령을 사용하면 됩니다. 그리고 해당 파일을 삭제하고, `/etc/fstab`에 등록했다면 해당 줄을 지워주면 됩니다.

	```c
	> sudo swapoff /var/swapfile
	> sudo rm /var/swapfile
	```

	

	

---

---

## 📌다같이 확인할 사항

### 1. 각 언어 특성에 맞는 가상 메모리 관리, 가비지 콜랙션(GC) 동작 방식에 대해 학습하고 정리한다.

<Swift ARC>

* 기초 운영체제 개념

	프로그램이 동작하려면 메모리 영역이 필요한데, 이는 OS에서 할당해줍니다. 이 때, 실제 물리적인 RAM의 주소를 알려주는 것이 아니라, 가상의 메모리 주소를 알려줍니다. 이렇게 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 주는 방식을 `가상 메모리` 방식이라고 합니다.

	![스크린샷 2022-01-19 오후 5 54 24](https://user-images.githubusercontent.com/92504186/150096744-e7ee9c48-e71c-435a-ac0e-c3fcdc4232d0.png)

	실제 RAM에 접근하는 일은 OS에서 담당하기 때문에, 프로그램에서는 실제 메모리 주소를 의식할 필요 없이 가상 공간 상에서 동작하면 됩니다.

	가상 공간에서는 연속된 메모리 공간처럼 생각하지만, 실제로는 여러 군데에 나누어 존재합니다. `페이징 방식`은 이렇게 가상 메모리 공간을 일정한 크기로 분할하여 각 공간을 각각 다른 물리적인 메모리 공간에 매핑하는 방식을 말합니다.

	일정한 크기로 나눈 가상 메모리 블록을 `Page`라고 하고, 같은 크기의 실제 메모리 블록은 `Frame`이라고 합니다. 

	각 프로세스에는 어떤 페이지가 어떤 물리 주소에 매핑되어야 하는지를 저장하고 있는 페이지 테이블이 존재합니다. 페이지 테이블에는 페이지 테이블 엔트리(PTE)들이 존재하고, 각 PTE에는 프레임 번호와 함께 추가적인 상태 비트가 저장됩니다.

	![스크린샷 2022-01-20 오전 11 02 54](https://user-images.githubusercontent.com/92504186/150250585-3fa82bf4-bf89-46c8-8525-5c14491398aa.png)

	> * Present/ Absent bit - valid/invalid bit라고도 하며, 해당 페이지가 메모리에 실제로 있는지를 나타냅니다.
	> * Protection bit - 해당 페이지의 보호를 위해 사용되는 비트입니다.
	> * Referenced bit - 이 페이지가 마지막 클럭 사이클에 접근되었는지를 나타냅니다.
	> * Caching enabled/disabled - 페이지의 캐시를 enable/disable하는 비트입니다.
	> * Modified bit - 페이지가 수정되었는지를 나타냅니다. 페이지가 수정되었다면, 수정된 정보는 하드 디스크 등에 다시 저장되어야 하기 떄문에 해당 페이지에 write할 때 하드웨어에 의해 1로 셋됩니다. 이 modified bit를 Dirty bit라고도 합니다.

* iOS의 Memory Footprint

	앱에서 메모리가 필요하면, 시스템에서 메모리 페이지를 줍니다. 이 페이지에는 여러 객체들이 저장됩니다. 큰 용량의 객체는 여러 페이징 ㅔ걸쳐서 존재할 수 있습니다. 한 페이지는 16KB정도이고, 가 페이지는 write한 적이 있는지에 따라서 Clean 또는 Dirty 메모리로 나뉩니다.

	한 앱 전체 메모리 사이즈는 다음 그림과 같이 계산할 수 있습니다.
	
	![스크린샷 2022-01-20 오전 11 24 05](https://user-images.githubusercontent.com/92504186/150260649-6dd0d9d2-7de5-4106-b7ed-edbfb27daa8a.png)
	
	
	
	일반적인 앱의 메모리는 다음 그림과 같은 세 부분으로 나뉘어집니다. Clean 메모리는 이미지, 프레임워크 데이터 등을 포함하며, Dirty 메모리는 객체 등 앱에서 수정한 데이터들과, 프레임 워크, dirty 메모리 등을 포함합니다.
	
	![스크린샷 2022-01-20 오전 11 25 20](https://user-images.githubusercontent.com/92504186/150260855-f6804a9f-6cec-4c85-881e-d88f9be2860d.png)
	
	Compressed Memory는 문자 그대로 압축된 메모리를 의미하는데, 일정 기간동안 특정 메모리 영역에 접근하지 않으면 시스템이 해당 메모리 페이지들을 압축하고, 다시 접근할 때 압축 해제합니다. iOS는 Memory Compressor를 이용해 이런 압축 또는 압축 해제 작업을 수행합니다.
	
	또한 앱이 할당 받을 수있는 메모리 Footprint에는 제한 한도가 존재하며, 이 한도치를 넘어가면 `EXC_RESOURCE_EXCEPTION`익셉션이 발생합니다.

