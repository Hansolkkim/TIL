* CS01 과제 수행

	* 소프트웨어 개발자는

		1. 개념과 방식을 이론적으로 학습하고, 원하는 동작, 연산 등을 소프트웨어로 직접 구현할 수 있다.
		2. 누군가 이미 구현해놓은 코드를 보고 왜 그런 방식으로? 생각으로? 구현했는지 찾아서 학습할 수 있다.

		이 두가지 방식을 계속 반복해서 학습을 해야한다. CS를 공부한다는 것은 CS 중 필수적인 지식을 학습하고, 직접 구현해보는 것이 `시작`이다!

	* CS01 과제의 제목은 `진법 변환기` 이다. 컴퓨터 구조에서는 모든 연산을 디지털 논리 회로를 이용해 진행한다. 따라서 이 진법 변환기를 공부하면서 컴퓨터가 무언가를 출력한다는게, 연산한다는게 어떤 방식으로 이루어지는지를 컴퓨터의 관점에서의 논리적 사고를 배울 수 있다.

	* 대학교에서 논리회로 강의를 들을 때 배웠던 Truth Table을 논리식으로 변환하는 방법이 이번 과제 수행에 많은 도움이 되었다.

		| 입력 A | 입력 B | 출력 |
		| ------ | ------ | ---- |
		| 0      | 0      | 1    |
		| 0      | 1      | 0    |
		| 1      | 0      | 1    |
		| 1      | 1      | 0    |

		임의대로 작성한 Truth Table을 바탕으로 논리식을 도출해보면,

		1. 출력이 1이 되는 행만 가지고 논리식을 만든다.

		2. 입력이 0일 때는 해당 입력의 기호에 ‘ 또는 -를, 입력이 1일 때는 해당 입력의 기호를 그대로 사용한다.

			위의 Truth Table의 첫번째 행은 A’ , B’ / 세번째 행은 A , B’ 으로 만들 수 있다.

		3. 같은 행에 있는 두 입력은 AND 연산으로 연결해 논리식을 만들고, 다른 행에 있는 논리식과는 OR 연산으로 연결한다.

			즉, 위 Truth Table의 최종적인 논리식은 `A’B’ + AB' = (A'+A)B' = B'`이다.

		이 방법을 이용해 전가산기의 carry와 SUM의 논리식을 만들어본다면, fullAdder 메소드의 내부 함수 carry와 SUM을 간단하게 만들 수 있다. 전가산기의 Truth Table은 아래와 같다.

		| 입력 A | 입력 B | 입력 C | 출력 Carry | 출력 SUM |
		| ------ | ------ | ------ | ---------- | -------- |
		| 0      | 0      | 0      | 0          | 0        |
		| 0      | 0      | 1      | 0          | 1        |
		| 0      | 1      | 0      | 0          | 1        |
		| 0      | 1      | 1      | 1          | 0        |
		| 1      | 0      | 0      | 0          | 1        |
		| 1      | 0      | 1      | 1          | 0        |
		| 1      | 1      | 0      | 1          | 0        |
		| 1      | 1      | 1      | 1          | 1        |

		SUM = A’B’C + A’BC’ + AB’C’ + ABC = A’(B ⊕ C) + A(B’C’ + BC) = A’(B ⊕ C) + A(B ⊕ C)’ = `A ⊕ B ⊕ C`

		Carry = A’BC + AB’C + ABC’ + ABC = `(A ⊕ B)C + AB`

	* 이진 덧셈기의 `추가학습거리`에 아래와 같은 질문이 있었고, [Eddy의 추천 글](https://jhnyang.tistory.com/226)을 통해 이 질문을 이해할 수 있었다.

		> 바이트 순서를 큰 비트(Most Significant Bit)를 좌측으로 배치하는 것과 우측으로 배치하는 방식이 구현할 때 어떤 장점이 있나?

		이번 과제에서는 바이트 순서를 큰 비트가 우측으로 배치되도록 했고, 이 방식을 `리틀엔디안`방식이라고 한다(반대의 경우를 `빅엔디안`방식이라고 한다.).

		이 방식을 사용할 경우, 아랫자리부터 연산을 시작하게 되므로, 만약 carry가 발생할 경우에 처리가 수월하다는 장점이 있다. 그로인해 `수학적 연산`이 쉽다는 장점이 있다. 또한, 타입형변환을 할 경우에도 리틀엔디안 방식이 빠르다. 만약 Int를 Int8 타입으로 `형변환`할 경우, 리틀엔디안 방식으로 처리될 경우에는 시작 주소부터 8bit 까지만 잘라주면 형변환이 간단하다. 반면 빅엔디안 방식에서는, 형변환시 앞의 수부터 끝까지 읽다가 맨뒤 8bit를 취함으로써 형변환하기 때문에 리틀엔디안 방식보다 형변환이 느리다고 한다.

		반면 `숫자 비교`를 할 경우에는 빅엔디안 방식이 리틀엔디안 방식보다 빠르다. 빅엔디안은 큰 자리수가 메모리 가장 처음에 위치하기 때문에 큰 자리수를 비교하기가 빠르다. 또한 빅엔디언 방식은 숫자를 읽고 쓰는 방법이 사람과 동일하기때문에, 디버깅 과정에서 메모리값을 보기가 편하다. 즉, `소프트웨어의 디버그` 측면에서는 빅엔디안이 유리하다.