## 오늘 계획

- [x] 프로젝트 회의 진행
- [x] CS 스터디 진행
- [x] 알고리즘 문제 풀기

## 회고

> Jed와 같이 하는 프로젝트에 대한 회의를 진행했다. 디자인을 정해보고, 피그마를 사용할 수 없으니 각자 프로젝트를 만들어 대략적인 디자인을 그려보기러 했다.
>
> 수월하게 회의가 잘 진행되어서 이후 진행도 순탄할 것 같았다.
>
> CS 스터디를 진행했는데, 오늘은 Jed의 인터뷰 차례였다. 나는 전에 할 때 적었던 내용들을 읽어보면서 대답을 했었는데 Jed는 기억해놓고 대답하는 모습을 보고, 내가 스터디에 제대로 임하고 있지 않다는 생각이 들어, 더 준비를 열심히 해야겠다고 생각했다.
>
> 알고리즘 강의도 들었는데, 첫 번째 문제에서 너무 많은 시간을 들였고, 다 풀지도 못 했다. 내일 마저 풀어봐야겠다...

# 알고리즘 풀이

- 새로 배웠던 내용

	1. 최단 경로 문제

		- 최단 경로 문제란, 두 노드를 잇는 가장 짧은 경로를 찾는 문제이다. 가중치 그래프의 경우, 간선 가중치의 합이 최소가 되도록 하는 경로를 찾는 것이다.

			보통 최단 경로 문제는 3가지 유형으로 나뉜다.

			1. 단일 출발 - 단일 도착 최단 경로
				- 그래프 내의 특정 노드 A에서 출발하여, 다른 특정 노드 B로 도착하는 가장 짧은 경로를 찾는 것이다. 즉, 특정 노드에서 특정 노드로 가는 최단 경로를 찾는 문제이다.
			2. 전체 쌍(all-pair) 최단 경로
				- 그래프의 모든 노드 쌍에 대한 최단 경로를 찾는 문제이다. A, B, C 세 노드가 있을 때, AB, AC, BC의 모든 경로의 최단 경로를 찾는 것을 의미한다.
			3. 단일 출발 최단 경로
				- 특정 노드와, 그래프에 존재하는 모든 노드와의 가장 짧은 경로를 찾는 문제이다. 이 경로에서 **다익스트라 알고리즘**이 사용된다고 한다.

		- 다익스트라 알고리즘

			- 첫 노드를 기준으로 연결되어 있는 노드들을 추가하면서 최단 거리를 갱신하는 알고리즘을 말한다

			- 다익스트라는 첫 노드로부터 그래프 내 모든 노드의 최단 거리를 찾는 것이고, 보통은 우선순위 큐로 구현하기 때문에 첫 노드로부터 모든 노드의 최단 거리를 저장할 배열과 우선순위 큐가 필요하다.

			- 아래와 같은 그래프가 있을 때, `1`번 노드를 기준으로 모든 노드의 최단 거리를 찾는 다익스트라 알고리즘을 구현해보려고 한다.

				<img src="https://raw.githubusercontent.com/Hansolkkim/Image-Upload/forUpload/img/202207201503754.png" alt="image-20220720150329628" width="50%;" />

				1. 초기화

					- 노드의 갯수만큼 배열을 생성하되, 첫 노드의 값은 0으로, 첫 노드를 제외한 모든 값을 무한대(최댓값이 주어져있다면 최댓값)로 초기화한다.

					- 우선순위 큐를 생성하고, 첫 노드의 가중치를 0으로 설정해 넣어준다.

						<img src="https://raw.githubusercontent.com/Hansolkkim/Image-Upload/forUpload/img/202207201505470.png" alt="image-20220720150548434" width="80%;" />

				2. 우선 순위 큐에서 값을 추출한 후 인접 노드들과 거리 계산

					- 우선 순위 큐에서 노드를 추출 (우선 순위 **큐**이기 때문에 가중치가 FIFO)

						<img src="https://raw.githubusercontent.com/Hansolkkim/Image-Upload/forUpload/img/202207201506082.png" alt="image-20220720150637038" width="80%;" />

					- 추출된 노드와 연결된 인접 노드와의 거리 + 추출된 노드의 가중치 값을 계산하여, 배열에 저장된 해당 노드의 값보다 작으면 배열을 업데이트하고, 그 값을 우선 순위 큐에 넣는다. (크기가 같거나 크면 아무런 작업을 하지 않음.)

						- 추출된 노드 0과 인접한 노드 1, 3과의 거리에 0 노드의 가중치(0)을 더하면,

							1. 0 -> 1 : 0 + 1 < 500000 (경로 저장 배열 중 1번 인덱스의 값) -> 배열 업데이트 후 해당 값을 우선순위큐에 넣음
							2. 0 -> 3 : 0 + 2 < 500000 (경로 저장 배열 중 3번 인덱스의 값) -> 배열 업데이트 후 해당 값을 우선순위큐에 넣음

							위와 같이 진행되므로 아래와 같이 배열의 값이 변한다.

						<img src="https://raw.githubusercontent.com/Hansolkkim/Image-Upload/forUpload/img/202207201511945.png" alt="image-20220720151112904" width="80%;" />

				3. 2번 작업을 우선 순위 큐가 빌 때까지 진행한다.

					- 2번째 반복

						- 추출된 노드 1과 인접한 노드 2, 4와의 거리에 1 노드의 가중치(1)을 더하면,
							1. 1 -> 2 : 3 + 1 < 50000 -> 배열 업데이트 후 해당 값을 우선 순위 큐에 넣음
							2. 1 -> 4 : 2 + 1 < 50000 -> 배열 업데이트 후 해당 값을 우선 순위 큐에 넣음

						<img src="https://raw.githubusercontent.com/Hansolkkim/Image-Upload/forUpload/img/202207201514746.png" alt="image-20220720151438689" width="80%;" />

					- 3번째 반복

						- 추출된 노드 3과 인접한 노드 0, 4와의 거리에 3 노드의 가중치(2)를 더하면,
							1. 3 -> 0 : 2 + 2 > 0 -> 변경 X
							2. 3 -> 4 : 2 + 2 > 3 -> 변경 X

						<img src="https://raw.githubusercontent.com/Hansolkkim/Image-Upload/forUpload/img/202207201516981.png" alt="image-20220720151623922" width="80%;" />

					- 4번째 반복

						- 추출된 노드 2와 인접한 노드 1, 4와의 거리에 2 노드의 가중치(4)를 더하면,
							1. 2 -> 1 : 3 + 4 > 1 -> 변경 X
							2. 2 -> 4 : 1 + 4 > 3 -> 변경 X

						<img src="https://raw.githubusercontent.com/Hansolkkim/Image-Upload/forUpload/img/202207201518040.png" alt="image-20220720151802992" width="80%;" />

					- 5번째 반복

						- 추출된 노드 4와 인접한 노드 1, 2, 3와의 거리에 4 노드의 가중치(3)를 더하면,
							1. 4 -> 1 : 2 + 3 > 1 -> 변경 X
							2. 4 -> 2 : 1 + 3 == 4 -> 변경 X
							3. 4 -> 3 : 2 + 3 > 2 -> 변경 X

				4. 이를 코드로 구현해보자.

					먼저, 그래프에 해당하는 값이 (road: [[Int]]) 의 형태로 들어온다고 가정하면,

					```swift
					let road = [[1,2,1],[2,3,3],[5,2,2],[1,4,2],[5,3,1],[5,4,2]]
					let max = 500000
					var 경로를_저장할_배열 = [Int](repeating: max, count: 5)
					var 우선순위큐 = [Int]()
					let start = 0
					
					경로를_저장할_배열[start] = 0
					우선순위큐 = [start]
					
					while !우선순위큐.isEmpty {
					    let 큐에서_추출된_값 = queue.removeFirst()
					
					    let filteredRoute = road.filter { $0[0] == 큐에서_추출된_값 || $0[1] == 큐에서 추출된 값 }
					
						for route in filteredRoute {
					        let destination = (route[0] == 큐에서_추출된_값) ?? route[1] : route[0]
					
					        if 경로를_저장할_배열[큐에서_추출된_값] == max { continue }
					
					        let currentDistance = 경로를_저장할_배열[큐에서_추출된_값] + route[2]
					
					        if currentDistance < 경로를_저장할_배열[destination] {
					            경로를_저장할_배열[destination] = currentDistance
					
					            queue.append(destination)
					        }
					    }
					}
					```

				5. 다익스트라 알고리즘의 시간 복잡도

					- 간선의 개수가 n인 다익스트라 알고리즘은 두 과정을 거치는데,

						1. 노드마다 인접한 간선을 모두 검사하는 과정 O(n)
						2. 우선 순위 큐에 insert/ pop 하는 과정 = O(logn)

						따라서, 이 둘울 곱한 O(nlogn)이 다익스트라 알고리즘의 시간복잡도이다.

-  학습 키워드

	`다익스트라 알고리즘`

- 참고 자료

	[[개발자 소들이] Swift) 최단 경로 :: 다익스트라 구현해보기](https://babbab2.tistory.com/110)

