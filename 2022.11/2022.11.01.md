## 오늘 계획

- [x] 뭐할지 생각해보기
- [x] 궁금증 관련 글써놓기

## 회고

> 두 달 간의 프로젝트의 기능을 어느 정도 마무리하고, 이제 뭘 더 할까 살피다가 막막함이 느껴졌다.
>
> 처음 내가 프로젝트를 시작할 때 목표를 다시 생각해보니,
>
> >   1.   RxSwift를 프로젝트에 자유롭게 적용할 수 있도록 하자.
> >   2.   무엇보다 취업을 위한 프로젝트이니, 채용 시 가장 많이 사용하는 `UICollectionView`에 대해 많이 공부하자.
> >   3.   아키텍처 선택에 대한 명확한 이유를 생각하면서 구조를 짜자.
>
> 와 같은 목표를 처음에 가졌던 것 같다.
>
> 지금와서 생각해보니, 프로젝트 진행 중일 때는 프로젝트 진행 중이니 미루고, 어느 정도 쉬는 시간이 생겼을 때도 프로젝트 관련 내용만 찾아보다보니 위의 계획들을 제대로 지킨게 있을까 싶은 생각이 든다.
>
> 가장 많이 생각나는 (해결하지 못 한) 궁금증은,
>
> >   1.   다른 분들의 프로젝트 레퍼런스들을 보면, UICollectionViewCell들도 ViewModel을 가지고 있다. 내 프로젝트에는 기껏 해봤자 ViewController가 ViewModel을 가지고 있는데, MVVM에서 ViewModel의 정확한 의미는 뭘까?
> >
> >   2.   UICollectionView의 Header, Footer에 만약 버튼이 있다면, 버튼이 눌린 Header, Footer의 IndexPath 등은 어떻게 알아차릴 수 있을까?
> >
> >   3.   MVVM + Rx 아키텍처로 할 때, ViewModel의 Input, Output을 다루는 방법은 상당히 많았다. 또한 Input, Output의 타입을 어떻게 결정할지 제대로 생각하지 못 했다. 
> >
> >        Rabit 프로젝트에서는 Input, Output을 Protocol로 정의하여 ViewModel이 해당 프로토콜들을 채택하도록 했는데, 이렇게 한 이유가 뭐였는지 제대로 기억도 안나고, 메이스는 Input, Output을 Struct로 정의하여 ViewModel Protocol 내의 associated type으로 가지고 있었고 뭔가 보기에 더 깔끔한 구조이기도 했다.
> >
> >        그리고 Input, Output의 프로퍼티들의 타입들도 어떤 레퍼런스에서는 Signal, Driver로만 정의한 경우가 많았는데, 만약 현재 뷰에서 다음 뷰에서 보여줘야할 어떤 데이터를 넘겨줄 때, 다음 뷰의 Output이 그저 Driver이기만 하면 화면 이동과 동시에 전달받은 데이터를 어떻게 화면에 바로 보여줄까?
>
> 먼저 위의 궁금증에 대해서 충분히 생각해보는 시간을 가져야겠다.
>
> 그리고 코딩을 하다보다 또다시 내 단점이 보였는데, 어렵다고 생각되는 부분을 공부하기를 무한정 미뤄버리는 것이다. 머리에서든 계획에서든,, 그리고 미루다 보면 까먹는다ㅎㅎ
>
> 그런 단점을 보안하려면 지금처럼 생각을 적어보는 시간을 한 번 씩 가지는게 좋을 것 같다. 적어놓으면 그래도 나한테서라도 부추김을 받지 않을까?
>
> 그리고 느즈막하게 블로그 포스팅을 조금 작성해보려는데, 여기서도 내가 부담을 느끼고 있는것 같다. 
>
> 길게적어야지, 더 자세하게 적어야지 하다보면 작성도 미루게 된다.
>
> 블로그는 그냥 내 공부 기록이라는 생각을 가지고 짧은 글로라도 "**작성**"하는게 해결책일 것 같다.
>

# 궁금증 해결

- 새로 배웠던 내용

    1.   ViewModel??

         먼저 MVVM의 정의에 대해 먼저 보자면, 위키백과에 아래와 같이 정의되어 있다.

         ![image-20221101162103733](https://raw.githubusercontent.com/Hansolkkim/Image-Upload/forUpload/img/202211011803189.png)

         -   MVVM은 그래픽 UI(View)의 개발을 **비즈니스 로직** 또는 **백엔드 로직**(모델)로부터 분리시켜서 뷰가 어느 특정한 모델 플랫폼에 종속되지 않도록 해주는 패턴이다. <sub>[위키백과](https://ko.wikipedia.org/wiki/모델-뷰-뷰모델)</sub>

         

         또한 위키백과에 정의되어있는 뷰모델의 정의는 아래와 같습니다.

         -   뷰 모델은 공용 속성과 공용 명령을 노출하는 뷰에 대한 추상화(abstraction)이다. MVVM은 바인더를 가지고 있는데 이는 뷰 모델에 있는 뷰에 연결된 속성과 뷰 사이의 통신을 자동화한다. 뷰 모델은 모델에 있는 데이터의 상태이다.
         -   뷰 모델과 MVP의 프리젠터 사이의 주요한 차이점은, 프리젠터는 뷰에 대한 참조를 가지고 있는 반면, 뷰 모델은 그렇지 않다는 것이다. 그 대신, 뷰는 뷰 모델의 속성에 직접 연결된 채로 업데이트를 주고 받는다.

         

         즉, 뷰를 그리기 위한 **상태**와 뷰로부터의 이벤트를 받기 위한 장치를 가지고 있는 객체이고, 직접 뷰를 참조하지는 않고 **바인딩**으로 뷰와 연결되어 있는 객체라는 결론을 내릴 수 있었다.

         토이 프로젝트를 진행하면서 ViewModel을 모든 ViewController가 가지도록 하고, RxSwift를 이용해 바인딩해주는 로직을 ViewController와 ViewModel 내에서 진행해주도록 했다.

         하지만 다른 레퍼런스들을 보니 UICollectionViewCell 등의 모든 View들이 ViewModel을 가지는 경우가 있어 ViewModel을 프로퍼티로 가지고 있는 주체가 누가 되어야할지 궁금했었는데, ViewModel의 정의를 보니 ViewModel은 <u>View와 바인딩되어 있는, 뷰의 추상화된 객체</u>이기 때문에, ViewModel은 ViewController가 아닌, 모든 View들이 가질 수 있는 객체라는 답을 얻었다.

    2.   Header에 버튼?

         사실 해당 궁금증도 위의 내용을 찾아보다가 어느정도 답을 얻었다.

         저는 ViewModel은 ViewController가 소유하고, ViewController, ViewModel 내에서만 바인딩해주어야 한다는 생각을 가지고 있었는데, Header/Footer와 같은 UICollectionReusableView 또한 ViewModel을 가지고 있다면 버튼이 눌린 Header/ Footer의 IndexPath를 받아올 필요 조차 없다는 결론에 이르렀다.

         만약 특정 Header의 버튼이 눌렸을 때 특정화면으로 이동해야 한다면, 해당 기능을 가지는 ViewModel을 Header에 바인딩시켜주면 된다.
         
    3.   3번은 천천히!

-  학습 키워드

    [[위키백과- MVVM]](https://ko.wikipedia.org/wiki/모델-뷰-뷰모델)

- 참고 자료


